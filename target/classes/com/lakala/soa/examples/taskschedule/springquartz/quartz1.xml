<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:soa="http://www.lakala.com/schema/soa"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
	http://www.lakala.com/schema/soa http://www.lakala.com/schema/soa/soa.xsd">

	<!-- QuartzJobBean 方式  得用  Quartz 1.8.x 以下版本 -->
	<!-- 作业使用继承QuartzJobBean的方式  -->  
	<bean name="job1" class="org.springframework.scheduling.quartz.JobDetailBean">
		<property name="jobClass" value="com.lakala.soa.examples.taskschedule.springquartz.Job1" />  
		<property name="jobDataAsMap">  
			<map>  
				<entry key="timeout" value="0" />  
			</map>  
		</property>  
	</bean> 	
	
	<!-- quartz 在2.0 时,org.quartz.CronTrigger从class变成了一个interface -->
	
	<!-- quartz-1.8以前的配置 --> 
    <!-- <bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean"> -->  
    
	<!-- quartz-2.x的配置 --> 
    <bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean">  
	    <property name="jobDetail" ref="job1" />  
	    <!-- 每分钟的第0,10,20,30,40,50秒调度一次 -->  
	    <property name="cronExpression" value="0,10,20,30,40,50 * * * * ?" />  
	    <!-- *******************************misfireInstruction******************************* -->
		<!-- 
		>>> CronTrigger
		* constant in the {@link org.quartz.CronTrigger} class.
	    * Default is {@code MISFIRE_INSTRUCTION_SMART_POLICY}.
	 	* @see org.quartz.CronTrigger#MISFIRE_INSTRUCTION_FIRE_ONCE_NOW
	 	* @see org.quartz.CronTrigger#MISFIRE_INSTRUCTION_DO_NOTHING
	 	* @see org.quartz.Trigger#MISFIRE_INSTRUCTION_SMART_POLICY
		MISFIRE_INSTRUCTION_FIRE_ONCE_NOW = 1
		MISFIRE_INSTRUCTION_DO_NOTHING = 2
		MISFIRE_INSTRUCTION_SMART_POLICY = 0
		MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY = -1
		
		>>> SimpleTrigger
		* constant in the {@link org.quartz.SimpleTrigger} class.
		* Default is {@code MISFIRE_INSTRUCTION_SMART_POLICY}.
		* @see org.quartz.SimpleTrigger#MISFIRE_INSTRUCTION_FIRE_NOW
		* @see org.quartz.SimpleTrigger#MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_EXISTING_COUNT
		* @see org.quartz.SimpleTrigger#MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT
		* @see org.quartz.SimpleTrigger#MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT
		* @see org.quartz.SimpleTrigger#MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT
		* @see org.quartz.Trigger#MISFIRE_INSTRUCTION_SMART_POLICY 
		MISFIRE_INSTRUCTION_FIRE_NOW = 1
		MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT = 2
		MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT = 3
		MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT = 4
		MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_EXISTING_COUNT = 5 
		MISFIRE_INSTRUCTION_SMART_POLICY = 0
		MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY = -1 
		
		所有的trigger都有一个Trigger.MISFIRE_INSTRUCTION_SMART_POLICY策略可以使用，该策略也是所有trigger的默认策略。
		如果使用smart policy，SimpleTrigger会根据实例的配置及状态，在所有MISFIRE策略中动态选择一种Misfire策略。
		SimpleTrigger.updateAfterMisfire()的JavaDoc中解释了该动态行为的具体细节。
		>>> CronTrigger
		@see org.quartz.impl.triggers.CronTriggerImpl#updateAfterMisfire
		>>> SimpleTrigger
		@see org.quartz.impl.triggers.SimpleTriggerImpl#updateAfterMisfire
		-->
		<!-- *******************************misfireInstruction******************************* -->
		<property name="misfireInstruction" value="0"/>
    </bean>  
    
    <bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">  
		<property name="triggers">  
			<list>  
				<ref bean="cronTrigger" />  
			</list>  
		</property>  
	</bean> 
	
</beans>
